import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from typing import List
from WarehouseLoader import *


def distance_aisles(name_insts: List[str], pop_max: int = 200) -> pd.DataFrame:
    """
    Estimate per-way travel distances per aisle for random rack-visit subsets,
    across one or more instances.

    For each instance, for each aisle, and for each possible number of visited
    racks `nb_prod` in [0..len(aisle)], this function samples up to `pop_max`
    subsets of racks (uniformly via random rank sorting). For each sampled way,
    it computes the path length: begin -> first visited -> ... -> last visited
    -> end, using the instance adjacency matrix as distances.

    Parameters
    ----------
    name_insts : List[str]
        List of instance folder names under ../data (e.g., ["warehouse_toy", "warehouse_big"]).
    pop_max : int, optional
        Maximum number of sampled combinations per `nb_prod` (default: 200).

    Returns
    -------
    pandas.DataFrame
        A DataFrame with columns:
        - `instance`: instance name
        - `aisle`: aisle index
        - `nb_racks`: number of racks in the aisle
        - `nb_prod`: number of visited racks in the path
        - `way`: sampled way index within (instance, aisle, nb_prod)
        - `distance`: total path length for that way
        Rows can be grouped easily with `df.groupby(["instance", "nb_racks", "nb_prod"])`.

    Notes
    -----
    - Subsets are generated by sorting random ranks (NumPy argsort trick), then
      taking the first `nb_prod` indices and sorting them ascending.
    - For `nb_prod == 0`, only begin -> end is accumulated (repeated pop_max times).
    """
    rows = []  # accumulate per-way records for the output DataFrame

    for name_inst in name_insts:
        inst = WarehouseLoader(f"../data/{name_inst}").load_all()
        dist = np.asarray(inst.adjacency)
        aisles_racks = inst.aisles_racks  # keep as list of lists

        for i, aisle in enumerate(aisles_racks):
            nb_racks = len(aisle)
            begin, end = aisle[0], aisle[-1]

            for nb_prod in range(0, nb_racks + 1):
                nb_ways = min(pop_max, math.comb(nb_racks, nb_prod))
                if nb_ways == 0:
                    continue

                if nb_prod == 0:
                    # No racks visited: only begin -> end, repeated nb_ways times
                    distances = np.full(nb_ways, dist[begin, end], dtype=float)
                    rows.append(pd.DataFrame({
                        "instance": np.full(nb_ways, name_inst),
                        "aisle": np.full(nb_ways, i, dtype=int),
                        "nb_racks": np.full(nb_ways, nb_racks, dtype=int),
                        "nb_prod": np.full(nb_ways, nb_prod, dtype=int),
                        "way": np.arange(nb_ways, dtype=int),
                        "distance": distances,
                    }))
                    continue

                # Random subsets via sorted random ranks (vectorized) -> indices within the aisle
                ways = np.random.rand(nb_ways, nb_racks).argsort(axis=1)[:, :nb_prod]
                ways = np.sort(ways, axis=1)  # ensure ascending order within each way

                # Map subset indices to actual rack IDs for this aisle
                racks_arr = np.asarray(aisle)
                ways_racks = racks_arr[ways]  # shape (nb_ways, nb_prod)

                # Distances: begin -> first, pairs within way, last -> end (vectorized)
                first_racks = ways_racks[:, 0]
                last_racks = ways_racks[:, -1]
                total = dist[begin, first_racks] + dist[last_racks, end]

                if nb_prod > 1:
                    prevs = ways_racks[:, :-1]
                    nexts = ways_racks[:, 1:]
                    total += dist[prevs, nexts].sum(axis=1)

                rows.append(pd.DataFrame({
                    "instance": np.full(nb_ways, name_inst),
                    "aisle": np.full(nb_ways, i, dtype=int),
                    "nb_racks": np.full(nb_ways, nb_racks, dtype=int),
                    "nb_prod": np.full(nb_ways, nb_prod, dtype=int),
                    "way": np.arange(nb_ways, dtype=int),
                    "distance": total,
                }))

    if not rows:
        return pd.DataFrame(columns=["instance", "aisle", "nb_racks", "nb_prod", "way", "distance"])
    return pd.concat(rows, ignore_index=True)


def stat_aisles(df: pd.DataFrame) -> pd.DataFrame:
	"""
	Compute summary statistics of distance differences per instance/aisle configuration.

	For each row where `nb_prod > 0`, the function computes the difference between
	the path distance and the baseline distance for the same `(instance, aisle)`
	with `nb_prod == 0`. It then aggregates these differences by `(instance, nb_racks, nb_prod)`
	to produce one row per triplet with the requested statistics.

	Parameters
	----------
	df : pandas.DataFrame
		Input DataFrame produced by `distance_aisles`, with columns:
		`instance`, `aisle`, `nb_racks`, `nb_prod`, `way`, `distance`.

	Returns
	-------
	pandas.DataFrame
		Aggregated statistics with one row per `(instance, nb_racks, nb_prod)` and
		columns: `min`, `p10`, `median`, `p90`, `max`, `mean`, `std`.

	Notes
	-----
	- Baseline rows are those with `nb_prod == 0`, matched by `(instance, aisle)`.
	- Differences are computed as `distance - baseline` before aggregation.
	"""
	# Baseline per (instance, aisle) where nb_prod == 0
	baseline = df[df["nb_prod"] == 0][["instance", "aisle", "distance"]].rename(columns={"distance": "baseline"})

	# Join to nb_prod > 0 rows and compute difference
	df_pos = df[df["nb_prod"] > 0].merge(baseline, on=["instance", "aisle"], how="left")
	df_pos = df_pos.dropna(subset=["baseline"])
	df_pos["diff"] = df_pos["distance"] / df_pos["baseline"] - 1

	# Aggregate with one row per (instance, nb_racks, nb_prod) and a column per statistic
	stats_df = (
		df_pos.groupby(["instance", "nb_racks", "nb_prod"])
			["diff"]
			.agg(
				min="min",
				p10=lambda s: s.quantile(0.1),
				median="median",
				p90=lambda s: s.quantile(0.9),
				max="max",
				mean="mean",
				std=lambda s: s.std(ddof=1),
			)
			.reset_index()
	)
	return stats_df


def plot_stats_by_instance_nb_racks(df):
    """
    Plot the evolution of statistics versus `nb_prod` for each (instance, nb_racks).

    For every unique `instance` and `nb_racks`, draws a figure with curves:
    - min, p10, median, p90, max: black color
    - mean: orange color
    - std: ignored

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame with columns:
        `instance`, `nb_racks`, `nb_prod`, `min`, `p10`, `median`, `p90`, `max`, `mean`.
    """
    required = {"instance", "nb_racks", "nb_prod", "min", "p10", "median", "p90", "max", "mean"}
    missing = required - set(df.columns)
    if missing:
        raise ValueError(f"Missing required columns: {sorted(missing)}")

    # Ensure nb_prod is sorted numerically
    df = df.copy()
    df["nb_prod"] = df["nb_prod"].astype(int)

    # Line styles for black curves to distinguish them visually
    black_stats = ["min", "p10", "median", "p90", "max"]
    black_styles = {
        "min": "-",
        "p10": ":",
        "median": "-.",
        "p90": ":",
        "max": "-",
    }

    for inst_name in sorted(df["instance"].unique()):
        df_inst = df[df["instance"] == inst_name]
        for nb_r in sorted(df_inst["nb_racks"].unique()):
            df_grp = df_inst[df_inst["nb_racks"] == nb_r].sort_values("nb_prod")
            x = df_grp["nb_prod"].values

            plt.figure(figsize=(9, 5))
            # Plot black stats
            for stat in black_stats:
                y = df_grp[stat].values
                plt.plot(x, y, color="black", linestyle=black_styles.get(stat, "-"), linewidth=1.6, label=stat)

            # Plot mean in orange
            plt.plot(x, df_grp["mean"].values, color="orange", linestyle="-", linewidth=2.0, label="mean")

            plt.title(f"Instance: {inst_name} | nb_racks={nb_r}")
            plt.xlabel("nb_prod")
            plt.ylabel("Statistic value")
            plt.grid(True, linestyle=":", alpha=0.3)
            plt.legend(ncol=2)
            plt.tight_layout()
            plt.show()
